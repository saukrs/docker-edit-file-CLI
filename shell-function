docker()
{
    local ARGS=("$@")

   #echo Argument count: $#
   #echo Docker cmd argument number: $(($#-3))
   #echo Container argument number: $(($#-2))
   #echo The file argument number: $(($#-1))

    local ARGNUM_OF_CMMD=$(($#-3))
    local ARGNUM_OF_SRVC=$(($#-2))
    local ARGNUM_OF_FILE=$(($#-1))

    # TODO: Count only non-option arguments (avoid options/switcher like `-d` or `--interactive` inbetween)

    if [[ "$#" < 3 || "${ARGS[$ARGNUM_OF_CMD]}" != "edit" ]]; then
        /usr/bin/env docker "$@"
        return $?
    fi

    local SRVC="${ARGS[$ARGNUM_OF_SRVC]}"
    local FILE="${ARGS[$ARGNUM_OF_FILE]}"

    # Temporary file to buffer content of the specific file from guest:
    TMPFILE=`mktemp "/tmp/bash-function-docker-edit-XXXXXXXX-$(basename $FILE).BUFFER"`

    echo TODO:
    echo Going to edit $FILE inside $SERVICE using $TMPFILE

    # The plan is to convert this command line:
    #
    #   docker ... edit CONTAINER FILE
    #
    # ... into something like that:
    #
    #   docker ... exec CONTAINER cat FILE

    # Inserting elements into array seems to be quite of an issue in Bash:
    # https://riptutorial.com/bash/example/19530/array-insert-function
    #
    # Thus we proceed with trimming tailf of the original command line and rewriting it instead:

    local ARGS_MAIN=(${ARGS[@]})
    unset -v ARGS_MAIN[$ARGNUM_OF_CMMD]
    unset -v ARGS_MAIN[$ARGNUM_OF_SRVC]
    unset -v ARGS_MAIN[$ARGNUM_OF_FILE]

    # Retrieve the file from guest into buffer:
    /usr/bin/env docker "${ARGS_MAIN[@]}" exec "${ARGS[$ARGNUM_OF_SRVC]}" cat "${ARGS[$ARGNUM_OF_FILE]}" > ${TMPFILE}

    # Edit the buffer:
    ${EDITOR:-vim} ${TMPFILE}
    RES=$?

    # Abort on editor abort:
    if [[ ! $RES -eq 0 ]]; then
        echo Docker file editing aborted. > /dev/stderr
        return $RES
    fi

    rm -v ${TMPFILE}
    return
}
